\chapter{Subgraph Matching}
L'operazione di \textit{subgraph matching} consiste nel trovare tutte le occorrenze di un grafo più piccolo (detto \textit{query graph}) all'interno di un grafo più grande (detto \textit{data graph}). Questa operazione è fondamentale in molte applicazioni, come il rilevamento di pattern in reti sociali, l'analisi di reti biologiche e la ricerca di strutture specifiche in database grafici.

\section{Isomorfismo di Grafi}
L'\textbf{isomorfismo} tra due grafi \(G_1\) e \(G_2\) è una corrispondenza biunivoca tra i loro insiemi di nodi che preserva le relazioni di adiacenza. In altre parole, due grafi sono isomorfi se esiste una mappatura tra i nodi di \(G_1\) e \(G_2\) tale che due nodi sono connessi da un arco in \(G_1\) se e solo se i loro corrispondenti nodi sono connessi da un arco in \(G_2\).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/subgraph_mapping_example.png}
    \caption{Esempio di subgraph mapping: il grafo di query (a sinistra) viene trovato all'interno del grafo di dati (a destra).}
    \label{fig:subgraph_mapping_example}
\end{figure}

\subsection{Automorfismo}
Un caso particolare di \emph{isomorfismo} è l'\textbf{automorfismo}: si verifica quando un grafo è isomorfo a se stesso. In altre parole, un automorfismo è una mappatura dei nodi di un grafo su se stessi che preserva le relazioni di adiacenza. Gli automorfismi sono importanti nello studio delle simmetrie nei grafi e possono essere utilizzati per semplificare la rappresentazione di un grafo.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/automorphism_example.png}
    \caption{Esempi di \emph{automorfismi} del grafo \(G\): a sinistra il grafo originale; al centro un automorfismo che scambia i vertici \(2\) e \(3\) mantenendo \(1\) fisso; a destra un secondo automorfismo che permuta i vertici come indicato dalle frecce tratteggiate. In entrambi i casi la struttura di adiacenza è preservata.}
    \label{fig:automorphism_example}
\end{figure}

\section{Operazione di subgraph matching}
L'operazione di \textit{subgraph matching} consiste, definita in modo più formale, nel verificare se il \emph{grafo query} è contenuto nel \emph{grafo dati} attraverso una mappatura che preserva le relazioni di adiacenza.

La differenza rispetto al concetto di isomorfismo risiede nel fatto che, nel subgraph matching, il grafo query può essere più piccolo del grafo dati e non è necessario che tutti i nodi del grafo dati siano coinvolti nella mappatura. Quindi , il subgraph matching cerca una corrispondenza parziale, \textbf{iniettiva}, tra i due grafi, mentre l'isomorfismo richiede una corrispondenza completa, \textbf{biunivoca}, tra tutti i nodi e gli archi dei due grafi.

Definiamo $G_1 = (V_1, E_1)$ come il grafo query e $G_2 = (V_2, E_2)$ come il grafo dati. L'operazione di subgraph matching cerca una funzione iniettiva \(f: V_1 \rightarrow V_2\) chiamata \textbf{mapping} tale che per ogni arco \((u, v) \in E_1\), l'arco \((f(u), f(v))\) appartiene a \(E_2\).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/subgraph_matching_example.png}
    \caption{Esempio di \emph{subgraph matching}: il grafo \emph{Query} (in alto a sinistra) viene ricercato all'interno del grafo \emph{Target} (in alto a destra). In basso sono mostrati i possibili match del sottografo query all'interno del grafo target, evidenziati dai riquadri rossi.}
    \label{fig:subgraph_matching_example}
\end{figure}

Come si vede dalla figura \ref{fig:subgraph_matching_example}, il processo di subgraph matching ritorna più occorrenze del grafo query all'interno del grafo dati, evidenziando le diverse mappature possibili che soddisfano le condizioni di adiacenza.

\section{Complessità computazionale}
L'operazione di graph matching è nota per essere computazionalmente complessa. Infatti, il problema del graph matching è NP-Hard, ovvero non esiste un algoritmo noto che possa risolverlo in tempo polinomiale per tutti i casi. Questo rende il graph matching un algoritmo particolarmente esoso.

Per quanto riguarda il subgraph matching, la complessità dipende dalla dimensione del grafo query e del grafo dati, nonché dalla struttura dei grafi stessi. In generale è un problema NP-Completo, il che significa che non esiste un algoritmo noto che possa risolverlo in tempo polinomiale per tutti i casi, tuttavia esistono algoritmi euristici e approssimativi che possono essere utilizzati per affrontare il problema in modo più efficiente in casi specifici o con vincoli particolari.

\section{Algoritmi di subgraph matching}
\subsection{Soluzione Bruteforce}
La soluzione più semplice per il problema del subgraph matching è l'approccio \textbf{bruteforce}, che consiste nel generare tutte le possibili mappature dei nodi del grafo query sui nodi del grafo dati e verificare se ciascuna mappatura preserva le relazioni di adiacenza.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.78\textwidth]{images/bruteforce_subgraph_matching.png}
    \caption{Ricerca \emph{brute force} per \emph{subgraph matching}: in alto i grafi \(G_a\) (query) e \(G_b\) (target); sotto l'albero di ricerca che esplora tutte le corrispondenze possibili tra vertici (es.\ \((1,4)\), \((1,5)\), \((1,6)\), \((1,7)\)). Le foglie evidenziate indicano i mapping completi che preservano le adiacenze (match isomorfi).}
    \label{fig:bruteforce_subgraph_matching}
\end{figure}

Questo è chiaramente una soluzione NP-Hard, inefficiente. Si possono adottare strategie migliori per velocizzare la computazione:
\begin{itemize}
    \item \textbf{Look-ahead}: prima di verificare una mappatura completa, si può controllare se i nodi parzialmente mappati soddisfano le condizioni di adiacenza. Se non lo fanno, si può scartare immediatamente quella mappatura. 
    \item \textbf{Backtracking}: si può utilizzare una strategia di backtracking per esplorare lo spazio delle mappature in modo più efficiente. Se si scopre che una mappatura parziale non può essere estesa a una mappatura completa valida, si torna indietro e si prova una diversa mappatura.
\end{itemize}

\paragraph{Esempio di backtracking.}
Partendo dalla radice dell'albero di ricerca (figura \ref{fig:backtracking_subgraph_matching}), assegnamo progressivamente i vertici del grafo \emph{query} ai vertici del \emph{target}. Dopo le prime scelte \((1\!\to\!a)\) e \((2\!\to\!b)\), proviamo \((3\!\to\!c)\). A questo punto un controllo locale sui vincoli struttura-preservanti rivela un'incoerenza: il grado di \(3\) nel query è 3, mentre quello di \(c\) nel target è 2; quindi nessun proseguimento potrà produrre un mapping valido. L'algoritmo esegue allora \emph{pruning} del ramo e \emph{backtracking} allo stato precedente per provare alternative (ad es.\ \((3\!\to\!d)\)). Questo comportamento evita esplorazioni inutili e riduce drasticamente lo spazio di ricerca.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/backtracking_subgraph_matching.png}
    \caption{Esempio di \emph{backtracking} con pruning nel \emph{subgraph matching}. A sinistra il grafo \emph{query} e il grafo \emph{target}; a destra l'albero di ricerca. Il ramo che mappa \((3\!\to\!c)\) viene potato perché viola un vincolo di grado (\(\deg(3)=3>\deg(c)=2\)), quindi non può condurre a una soluzione.}
    \label{fig:backtracking_subgraph_matching}
\end{figure}

\subsection{Algoritmo di Ullmann}
L'algoritmo di Ullman utilizza il grado del nodo come criterio di selezione per ridurre lo spazio di ricerca. In particolare, prima di tentare una mappatura, l'algoritmo verifica se il grado del nodo nel grafo query è minore o uguale al grado del nodo corrispondente nel grafo dati. Se questa condizione non è soddisfatta, la mappatura viene scartata immediatamente (\emph{look-ahead}).

Dopo aver costruito una mappatura iniziale, l'algoritmo applica una procedura di \textbf{refinement} per eliminare ulteriori mappature non valide. Questa procedura verifica che per ogni arco nel grafo query, l'arco corrispondente esista nel grafo dati. Se un arco manca, la mappatura viene scartata (\emph{backtracking}).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{images/ullmann_algorithm_example.png}
    \caption{Algoritmo di Ullmann: a sinistra il grafo \emph{query} \(Q\) e il grafo \emph{target} \(T\); a destra l'albero di ricerca con le corrispondenze provate. I nodi cerchiati in rosso indicano scelte scartate tramite \emph{pruning}; il ramo con \((3,7)\) completa un mapping valido.}
    \label{fig:ullmann_algorithm_example}
\end{figure}

\paragraph{Esempio della figura \ref{fig:ullmann_algorithm_example}.}
Per prima cosa si calcola l'ordine di ogni vertice, nel grafo $Q$ abbiamo \( deg(1) = deg(2) = deg(5) \), nel grafo $T$ abbiamo \( deg(6) = deg(7) = \deg(5) = 2, deg(4) = 1 \).

L'obiettivo è quello di trovare un \emph{isomorfismo} tra i due grafi, iniziando dalla radice dell'albero di ricerca. Si prova l'assegnazione \((1, 4)\) ma viene scartata perché il grado di \(1\) è maggiore del grado di \(4\). Si prova quindi \((1, 5)\) e si procede con \((2, 4\) (non funziona per lo stesso motivo \( (1, 4)\)) , quindi si prova \((2, 6)\) e così via. Alla fine si trova il mapping valido \((1, 5), (2, 6), (5, 7)\).

\subsection{Algoritmo VF}
L'algoritmo VF (Vento-Foggia) è un altro approccio per il problema del subgraph matching che utilizza una strategia di backtracking con pruning basata su vincoli locali. L'algoritmo costruisce una mappatura incrementale dei nodi del grafo query sui nodi del grafo dati, verificando a ogni passo se la mappatura parziale soddisfa i vincoli di adiacenza.

\noindent
L'algoritmo costruisce 3 insiemi per ognuno dei grafi $Q, T$:
\begin{itemize}
    \item $M_Q, M_T$: nodi già mappati
    \item $T_Q, T_T$: nodi adiacenti a quelli mappati
    \item $U_Q, U_T$: nodi non ancora considerati
\end{itemize}

\noindent
Dove il pedice $Q$ o $T$ indica se l'insieme appartiene al grafo query o target.

\textbf{N.B.} È importante notare che l'algoritmo VF è ricorsivo ma lavora a \textbf{stati}: ad ogni passo ricorsivo considera lo stato attuale in cui, definito dagli insiemi di nodi mappati, adiacenti e non ancora considerati.


\paragraph{Algoritmo.}
Ad ogni passo dell'algoritmo, per lo stato corrente $s$, si eseguono i seguenti passi:
\begin{enumerate}
    \item Si seleziona un nodo $q \in T_Q(s)$ e si prova a mappare $\forall t \in T_T(s)$.
    \item Si verifica la regola di \textbf{fattibilità} per un certa coppia $(q, t) \in T_Q(s) \times T_T(s)$. Se la coppia è fattibile, si crea un nuovo stato $s'$ aggiornando gli insiemi $M_Q, M_T, T_Q, T_T, U_Q, U_T$ di entrambi i grafi. Da notare che si preferisce sempre scegliere una coppia di nodi che il grado più alto possibile, in modo da massimizzare le possibilità di pruning e ridurre la computazione nel caso medio.
    \item Si ripete il processo fino a quando tutti i nodi del grafo query sono stati mappati (trovando così un match) o fino a quando non ci sono più nodi da mappare (in tal caso si esegue il backtracking).
\end{enumerate}

\paragraph{Regola di fattibilità per grafi indiretti.}
Una coppia di nodi $(q, t) \in T_Q(s) \times T_T(s)$ è considerata fattibile se soddisfa le seguenti condizioni:
\begin{itemize}
    \item Per ogni nodo query $q' \in M_Q(s)$ connesso a $q$, esiste un nodo target $t' \in M_T(s)$ connesso a $t$.
    \item Il numero di nodi query in $T_Q(s)$ deve essere minore o uguale\footnote{Minore o uguale nel caso di subgraph matching, nel caso di graph matching invece deve essere uguale.} al numero di nodi target in $T_T(s)$ (regola look-ahead a un livello).
    \item Il numero di nodi query in $U_Q(s)$ deve essere minore o uguale\footnote{Anche qui,minore uguale solo nel caso di subgraph matching. Nel caso di Graph deve essere uguale.} al numero di nodi target in $U_T(s)$ (regola look-ahead a due livelli).
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{images/vf_algorithm_example.png}
    \caption{Rappresentazione grafica dei sei insiemi utilizzati dall'algoritmo VF per verificare la regola di fattibilità durante la costruzione incrementale della mappatura tra nodi del grafo query $Q$ e nodi del grafo target $T$.  
    La figura mostra, per uno stato $s$ dell'algoritmo, la suddivisione di entrambi i grafi nei tre insiemi fondamentali: i nodi già mappati ($\text{Match}_Q(s)$ e $\text{Match}_T(s)$), i nodi adiacenti a quelli mappati ($\text{Term}_Q(s)$ e $\text{Term}_T(s)$) e i nodi non ancora considerati ($\text{Rem}_Q(s)$ e $\text{Rem}_T(s)$).  
    Le frecce tratteggiate indicano le possibili connessioni tra nodi dei diversi insiemi, mentre le frecce orizzontali centrali rappresentano la mappatura parziale $M(s)$ costruita dallo stato corrente.  
    Questa struttura consente di verificare la regola di fattibilità: ogni nuova coppia $(q,t)$ può essere aggiunta alla mappatura se preserva le adiacenze verso i nodi già mappati, se esistono sufficienti nodi adiacenti disponibili (look-ahead a un livello) e se esistono sufficienti nodi non ancora considerati per supportare eventuali mappature future (look-ahead a due livelli).}
    \label{fig:vf_algorithm_example}
\end{figure}

\paragraph{Regola di fattibilità per grafi diretti.}
Nel caso di grafi diretti, la regola di fattibilità deve considerare anche la direzione degli archi. Quindi, ogni grafo non ha più 3 insiemi di nodi ma 6:
\begin{itemize}
    \item $M_Q^{in}, M_T^{in}$: nodi già mappati considerando gli archi entranti
    \item $M_Q^{out}, M_T^{out}$: nodi già mappati considerando gli archi uscenti
    \item $T_Q^{in}, T_T^{in}$: nodi adiacenti a quelli mappati considerando gli archi entranti
    \item $T_Q^{out}, T_T^{out}$: nodi adiacenti a quelli mappati considerando gli archi uscenti
    \item $U_Q, U_T$: nodi non ancora considerati
\end{itemize}

\noindent
La regola di fattibilità in questo caso, deve essere modificata per tenere conto delle direzioni degli archi:
\begin{itemize}
    \item Per ogni nodo query $q' \in M_Q^{in}(s)$, predecessore di $q$, esiste un nodo target $t' \in M_T^{in}(s)$ predecessore di $t$.
    \item Per ogni nodo query $q' \in M_Q^{out}(s)$, successore di $q$, esiste un nodo target $t' \in M_T^{out}(s)$ successore di $t$.
    \item Il numero di nodi query in $T_Q^{in}(s)$ deve essere minore o uguale al numero di nodi target in $T_T^{in}(s)$.
    \item Il numero di nodi query in $T_Q^{out}(s)$ deve essere minore o uguale al numero di nodi target in $T_T^{out}(s)$.
    \item Il numero di nodi query in $U_Q(s)$ deve essere minore o uguale al numero di nodi target in $U_T(s)$.
\end{itemize}

\paragraph{Complessità e considerazioni}
La complessità, nell'ipotesi che i due grafi abbiano $N$ nodi, si può calcolare come:
\begin{enumerate}
    \item Sapendo che ogni nodo ha in media $O(N)$ nodi adiacenti, quindi per ogni nodo query si devono considerare $O(N)$ possibili mappature nel grafo target.
    \item Per ogni mappatura, si devono verificare le condizioni di fattibilità, che richiedono di controllare gli archi adiacenti. Questo richiede $O(N)$ operazioni.
\end{enumerate}

Quindi nel caso migliore, la complessità dell'algoritmo dipende dalla visita di un solo nodo candidato per ogni nodo query, portando a una complessità di \(O(N^2)\). Tuttavia, nel caso peggiore, l'algoritmo potrebbe dover esplorare tutte le possibili mappature, portando a una complessità esponenziale di \(O(N!)\).

La complessità spaziale, al più $k$ stati (dove $k$ è il numero di nodi del grafo query) porta a una complessità spaziale di \(O(k \cdot N)\), considerando che per ogni stato si devono memorizzare gli insiemi di nodi mappati, adiacenti e non ancora considerati per entrambi i grafi.

\subsection{Algoritmo VF2}
L'algoritmo VF2 è un miglioramento dell'algoritmo VF, progettato per essere più efficiente nel risolvere il problema del subgraph matching. VF2 ottimizza lo spazio utilizzato, fino ad ottenere una complessità spaziale pari a $O(N)$, utilizzando strutture dati globali e condivise tra i vari stati. Si introducono sei strutture dati:
\begin{itemize}
    \item $\text{core}_1$ e $\text{core}_2$: array che memorizzano la mappatura corrente dei nodi del grafo query e del grafo target, rispettivamente.
    \item $\text{in}_1$ e $\text{in}_2$: array booleani che indicano se un nodo è adiacente a un nodo già mappato (insiemi $\text{Term}_Q$ e $\text{Term}_T$).
    \item $\text{out}_1$ e $\text{out}_2$: array booleani che indicano se un nodo non è ancora considerato (insiemi $\text{Rem}_Q$ e $\text{Rem}_T$).
\end{itemize}

Grazie a queste strutture, si può \emph{tracciare} contemporaneamente l'appartenenza dei nodi agli insiemi necessari per la verifica della regola di fattibilità, senza dover mantenere insiemi separati per ogni stato dell'algoritmo. Questo riduce significativamente l'overhead di memoria, permettendo all'algoritmo di gestire grafi più grandi in modo più efficiente.

\subsection{Algoritmo RI}
L'algoritmo RI è un approccio alternativo per il problema del subgraph matching. Gli algoritmi VF si basano su una strategia di backtracking con pruning, mentre l'algoritmo RI si concentra invece \textbf{sull'ordine} in cui i nodi della query vengono processati nell'albero di ricerca. Un ordinamento efficace, infatti, \emph{velocizza} molto il matching anche in presenza di regole di pruning meno restrittive rispetto a VF.

In particolare, l'ordinamento in RI è calcolato indipendentemente dal grafo target (static ordering) e si può riassumere nei seguenti passi:
\begin{enumerate}
    \item Si ordinano i nodi del grafo query in modo da \textbf{massimizzare} la probabilità che un cammino parziale nell'albero di ricerca venga tagliato il prima possibile.
    \item Seguendo l'ordinamento calcolato al passo 1, si mappano i nodi della query a nodi del target verificando per ogni coppia candidata $(q, t)$ che:
    \begin{enumerate}
        \item $q$ e $t$ non siano già stati mappati ad altri nodi.
        \item Il grado di $q$ sia minore o uguale al grado di $t$.
    \end{enumerate}
    \item Si ripete il passo 2 finché l'intero spazio di ricerca non viene esplorato.
\end{enumerate}

\paragraph{Ordinamento dei nodi.}
Il punto principale di questo algoritmo è capire come ordinare i nodi della query per massimizzare l'efficacia del pruning. L'obiettivo dell'ordinamento è quello di costruire una sequenza ordinata di nodi \( [q_1, q_2, \ldots, q_n] \) tale che, durante la ricerca, i nodi connessi ai nodi già mappati vengano processati il prima possibile. Questo aumenta la probabilità che le condizioni di fattibilità vengano violate precocemente, permettendo di tagliare rami dell'albero di ricerca in modo più efficiente. Per farlo, si può definire una \textbf{regola generale}: al passo $i$, si sceglie il nodo $q_i$ con grado più alto e con un elevato numero di connessioni con i nodi già presenti nell'ordinamento $\bigcup^{i-1}$.

Sia $\bigcup^{i-1} = \{q_1, q_2, \ldots, q_{i-1}\}$ la sequenza parziale già ordinata al passo $i-1$. Allora, il punteggio di un nodo candidato $v$ da inserire nell'ordinamento è definito sulla base di 3 insiemi:
\begin{enumerate}
    \item $V_{adj}(i)$: insieme dei nodi adiacenti a $v$ che sono già presenti in $\bigcup^{i-1}$.
    \item $V_{conn}(i)$: insieme dei nodi in $\bigcup^{i-1}$ adiacenti ad almeno un nodo che non appartiene a $\bigcup^{i-1}$ ed è connesso a $v$.
    \item $V_{rem}(i)$: insieme dei nodi non ancora considerati (cioè non in $\bigcup^{i-1}$) e non connessi a nessun nodo in $\bigcup^{i-1}$, ma connessi a $v$.
\end{enumerate}

Da questo si crea un punteggio per il successivo nodo da inserire:
\begin{enumerate}
    \item Massimo valore di $|V_{adj}(i)|$.
    \item In caso di parità, massimo valore di $|V_{conn}(i)|$.
    \item In caso di ulteriore parità, massimo valore di $|V_{rem}(i)|$.
\end{enumerate}

\noindent
Se ancora dovesse esserci parità, si sceglie il nodo con il grado più alto.


\subsubsection*{Esempio.}
Consideriamo il grafo di query \(Q\) nella figura \ref{fig:ri_algorithm_example} 

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{images/ri_algorithm_example.png}
    \caption{Grafo non diretto di esempio (11 nodi, 0-10), usato per illustrare l'ordinamento dei nodi della query nell'algoritmo RI.}
    \label{fig:ri_algorithm_example}
\end{figure}

\paragraph{Passo $i=1$.}
Per prima cosa, dobbiamo ordinare i nodi. Lo stato iniziale dell'ordinamento è $U^0 = \emptyset$, per ogni nodo $v$ calcoliamo i 3 insiemi:
\[
|V_{\text{adiac}}(1,v)| = 0, \quad |V_{\text{conn}}(1,v)| = 0, \quad |V_{\text{rem}}(1,v)| = \deg(v)
\]
Quindi vince il nodo con grado massimo, ovvero il nodo 4. Ora lo stato dell'ordinamento è $U^1 = (4)$.

\paragraph{Passo $i=2$.}
Possiamo calcolare una tabella per tutti i candidati al passo 2, in quanto ora $U^1 = (4)$.

\begin{table}[htbp]
\centering
\footnotesize
\begin{tabular}{c|ccc}
\textbf{Nodo $v$} & $V_{\text{adiac}}(2,v)$ & $V_{\text{conn}}(2,v)$ & $V_{\text{rem}}(2,v)$ \\
\hline
0  & \{4\}       & \{4\}       & \{9\}       \\
1  & \{4\}       & \{4\}       & \{2\}       \\
2  & $\varnothing$ & \{4\}     & $\varnothing$ \\
3  & \{4\}       & \{4\}       & $\varnothing$ \\
5  & \{4\}       & \{4\}       & \{2,8\}     \\
6  & \{4\}       & \{4\}       & \{9\}       \\
7  & \{4\}       & \{4\}       & \{8\}       \\
8  & $\varnothing$ & \{4\}     & $\varnothing$ \\
9  & $\varnothing$ & \{4\}     & \{10\}      \\
10 & $\varnothing$ & $\varnothing$ & \{9\}   \\
\end{tabular}
\end{table}

In questo caso, si nota che i nodi candidati hanno $|V_{\text{adiac}}| = 1$. e $|V_{\text{conn}}| = 1$. Quindi si passa a guardare $|V_{\text{rem}}|$, che è massimo per il nodo 5 (2 nodi). Quindi il secondo nodo dell'ordinamento è $u_2$ = 5, e lo stato diventa $U^2 = (4, 5)$.

\paragraph{Tabella finale}
Dopo aver ripetuto questo processo per tutti i nodi, otteniamo l'ordinamento finale:
\[
U = (4, 5, 1, 3, 7, 0, 6, 9, 2, 8, 10)
\]


\subsection{RI-DS}
Una versione ottimizzata dell'algoritmo RI, chiamata RI-DS (RI with Domain Size ordering), introduce un'ulteriore strategia di ordinamento basata sulle dimensioni del \textbf{dominio} di ciascun nodo della query. In particolare si cerca di applicare la regola del grado di Ullman in fase di matching una sola volta per una stessa coppia $(q, t)$ e ridurre a monte le possibili coppie candidate. Questo perché se un nodo $q$ della query ha un grado maggiore di un nodo $t$ del target, allora non può esistere una mappatura valida che includa la coppia $(q, t)$.

Si può definire, per un certo nodo $q$ della query, il suo \textbf{dominio} $D(q)$ come l'insieme dei nodi del grafo target che possono essere mappati a $q$ rispettando la condizione del grado:
\[
D(q) = \{t \in V_T: deg(q) \leq deg(t)\}
\]
dove $deg(x)$ indica il grado del nodo $x$. Da questo, l'algoritmo esegue i seguenti passi:
\begin{enumerate}
    \item Ordina i nodi del grafo query.
    \item Calcola i domini per ogni nodo query.
    \item SEguendo l'ordinamento calcolato al passo 1, si mappano i nodi della query a nodi del target verificando per ogni coppia candidata $(q, t)$ che:
    \begin{enumerate}
        \item $q$ e $t$ non siano già stati mappati ad altri nodi.
        \item $t \in D(q)$, ovvero il nodo target $t$ appartiene al dominio del nodo query $q$.
    \end{enumerate}
    \item Si ripete il passo 3 finché l'intero spazio di ricerca non viene esplorato.
\end{enumerate}

\section{Subgraph Matching in Database di Grafi}
Il problema del subgraph matching è di fondamentale importanza nei database di grafi, dove si desidera trovare sottografi specifici all'interno di uno o più grafi target. Il problema diventa particolarmente rilevante in applicazioni come la bioinformatica, l'analisi delle reti sociali e la ricerca di pattern in grandi dataset.

La vera sfida in questi scenari è l'efficienza: i database di grafi possono contenere milioni o addirittura miliardi di nodi e archi, rendendo il subgraph matching un compito computazionalmente intensivo. 

\subsection{Indicizzazione}
Una soluzione \emph{naif} consisterebbe nell'eseguire il subgraph matching su ogni grafo del database; tuttavia, ciò sarebbe proibitivo in termini di tempo.

Per ottenere tempi ragionevoli, si indicizzano i grafi del database così da \textbf{filtrare} rapidamente i candidati rilevanti per una data query. L'idea è il classico paradigma \emph{filter-and-verify}: prima si usa l'indice per selezionare soltanto i grafi che condividono con la query determinate \emph{caratteristiche discriminanti} (ad es.\ frequenti sottografi, cammini/percorsi $q$-gram, firme di vicinato, conteggi di etichette e gradi), poi si applica il subgraph matching \emph{solo} su questo sottoinsieme ristretto. In questo modo si riduce drasticamente il numero di confronti, concentrando l'attenzione sui grafi con una reale possibilità di contenere il sottografo cercato, e migliorando sensibilmente i tempi di risposta senza sacrificare la correttezza del risultato.

\noindent
Esistono due tipi di indicizzazione:
\begin{description}
    \item[Indicizzazione basata su feature] - il grafo viene rappresentato tramite un insieme di \emph{feature} (sottografi frequenti, cammini, alberi, ecc.) che catturano le sue proprietà strutturali. Queste feature vengono poi memorizzate in un indice che consente di recuperare rapidamente i grafi che contengono determinate feature.
    \item[Indicizzazione non basata su feature] - i grafi vengoono mappati in uno spazio metrico e memorizzato in un \textbf{albero} (come un B-tree) dove fare ricerca basata su distanze. In questo modo, si possono recuperare rapidamente i grafi che sono "vicini" alla query in termini di struttura.  
\end{description}

\section{Features dei grafi}
Le \textbf{feature} sono delle proprietà strutturali dei grafi che possono essere utilizzate per l'indicizzazione e il filtraggio nei database di grafi. Si possono estrarre dal grafo diverse feature:
\begin{itemize}
    \item \textbf{Piccoli sottografi}: si possono identificare e memorizzare piccoli sottografi frequenti all'interno del grafo. Questi sottografi possono essere utilizzati come feature per rappresentare la struttura del grafo.
    \item \textbf{Cammini e percorsi}: si possono estrarre cammini di lunghezza fissa (chiamati $q$-gram) o percorsi specifici all'interno del grafo. Questi cammini possono essere utilizzati per confrontare la struttura dei grafi.
    \item \textbf{Alberi}: si possono identificare alberi radicati o alberi di profondità limitata all'interno del grafo. Questi alberi possono essere utilizzati come feature per rappresentare la struttura gerarchica del grafo.
\end{itemize}

\paragraph{Esempio di filtraggio tramite profili di feature.}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/feature_indexing_example.png}
  \caption{Indicizzazione \emph{feature-based} per il filtraggio dei candidati.
  A sinistra: dalla query \(Q\) si estraggono piccole caratteristiche (feature) e
  si costruisce il profilo di frequenza \(F_Q\).
  A destra: per ogni grafo del database (es.\ \(G\)) è precomputato il profilo \(F_G\).}
  \label{fig:feature_indexing_example}
\end{figure}

L'idea è rappresentare sia la query \(Q\) sia ciascun grafo \(G\) con un vettore/multinsieme di \emph{feature} e delle loro occorrenze (cammini, piccoli pattern etichettati, ecc.).  
Nel riquadro di sinistra, \(F_Q\) riporta per ogni feature il numero richiesto dalla query: una di esse richiede \(3\) occorrenze, altre due compaiono almeno una volta.  
Nel riquadro di destra, \(F_G\) mostra le occorrenze del medesimo insieme di feature nel grafo candidato \(G\).

Regola di filtro: se esiste una feature \(f\) tale che \(F_Q(f) > F_G(f)\), allora \(G\) \emph{non} può contenere \(Q\) e viene scartato.  
Nell'immagine, per una feature \(Q\) richiede \(3\) occorrenze mentre \(G\) ne ha \(1\) (\(\rightarrow\) \emph{2 occorrenze mancanti}); inoltre due feature presenti in \(Q\) non compaiono in \(G\) (\emph{2 feature mancanti}). Il grafo \(G\) viene dunque escluso già in fase di filtro, riducendo il numero di candidati da passare al subgraph matching.

\subsection{Schema di subgraph matching in database di grafi}
Nel caso di database di grafi, il subgraph matching segue lo schema \emph{filter-and-verify} (filtra e verifica):
\begin{enumerate}
    \item \textbf{Preprocessing}: per ogni grafo del database, si estraggono tutte le features rilevanti che contiene.
    \item \textbf{Filtering}: dalla query si estraggono tutte le feature contenute e si confrontano con quelle dei grafi del database, scartando quelli che non le contengono tutte.
    \item \textbf{Matching}: per ogni grafo rimanente, si esegue l'algoritmo di subgraph matching (ad es.\ VF2, RI-DS) per verificare se la query è effettivamente un sottografo del grafo target.
\end{enumerate}

Grazie a questo schema, si riduce drasticamente il numero di grafi su cui eseguire il subgraph matching, migliorando l'efficienza complessiva del processo.

\subsection{Indicizzazione inversa}
Un'altra tecnica di indicizzazione nei database di grafi è l'uso di un indice inverso\footnote{per indice inverso si intende una struttura dati che mappa feature a grafi contenenti tali feature} basato sulle feature. Ad ogni feature (intesa come chiave) si associa la lista dei grafi che la contengono, con il relativo numero di occorrenze della feature.

L'insieme dei candidati per il matching si può ottenere per intersezione delle liste dei grafi associate a ciascuna feature della query. In questo modo, si ottiene rapidamente l'insieme ristretto di grafi che contengono tutte le feature richieste dalla query, riducendo il numero di confronti necessari per il subgraph matching.

\subsection{Algoritmo SING}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{images/sing_algorithm_example.png}
    \caption{Query \(Q\) (angolo con nodo \(A\) adiacente a \(B\) e \(C\)) e due grafi candidati. 
    Nel grafo \(g_1\) il pattern è presente come \emph{subgrafo non indotto}, ma non come \emph{indotto} a causa dell'arco diagonale aggiuntivo; 
    nel grafo \(g_2\) il pattern è presente anche come \emph{subgrafo indotto}.}
    \label{fig:sing_algorithm_example}
\end{figure}

\noindent
L'algoritmo SING (Subgraph search In Non-homogeneous Graphs) è un algoritmo di subgraph matching in un database di grafi basato su indexing tramite cammini di nodi. Per migliorare l'efficacia dell'indicizzazione si associa ad ogni feature la frequenza di occorrenza in ogni grafo del database ed il nodo da cui parte. 

L'algoritmo utilizza due tipi di \textbf{indicizzazione} (come si vede in figura \ref{fig:sing_indexing_example}):
\begin{description}
    \item[Indice inverso globale] - ad ogni feature si associa la lista dei grafi del database che la contengo e il relativo conteggio di occorrenze. Questo aiuta a filtrare rapidamente i grafi che non contengono tutte le feature della query.
    \item[Indice inverso locale per ciascun grafo $\mathbf{g}$] - per ogni feature presente in $g$ è associato un vettore binario dove l'$i$-esimo bit indica se la feature parte dal nodo $i$ di $g$. Questo aiuta a velocizzare il processo di matching all'interno di ciascun grafo candidato.
\end{description}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{images/sing_indexing_example.png}
    \caption{Indicizzazione inversa globale e locale per l'algoritmo SING.
    A sinistra: indice inverso globale che associa ad ogni feature a lista dei grafi che la contengono e il conteggio delle occorrenze.
    A destra: indice inverso locale per il grafo \(g_1\), dove per ogni feature è indicato un vettore binario che mostra i nodi di partenza della feature in \(g_1\).}
    \label{fig:sing_indexing_example}
\end{figure}

\paragraph{Processamento della query.}
L'algoritmo procede a eseguire una query di subgraph matching seguendo questi passi:
\begin{enumerate}
    \item Si esegue il \textbf{primo filtraggio}, ovvero per ogni feature $F$ della query si recuperano i grafi che la contengono, per un maggiore numero di volte del grafy query, dall'indice inverso globale. Si ottiene così un insieme di grafi candidati che contengono tutte le feature della query e poi insieme si calcola l'intersezione $R$.
    \item Dopo si esegue un \textbf{secondo filtraggio}, per ogni grafo $G \in R$ si usa l'indica locale per calolcare gli insiemi di nodi compatibili con i nodi della query. Da quello, si scartano i grafi che non hanno almeno un nodo compatibile per ogni nodo della query. Questo, dato un vertice $v$ della query, calcola l'insieme dei vertici di un grafo $G$ del database che sono compatibili con $v$. Si dice compatibile un nodo $u$ di $G$ se esiste almeno una feature che parte da $v$ nella query e da $u$ in $G$. Dato $S$ insieme di queste features che partono da $v$, è sufficiente calcolare nell'indice locale del grafo $G$ un AND logico tra i vettori binari associati alle feature di $S$ e se restituisce un vettore non nullo, allora esiste almeno un nodo compatibile con $v$ in $G$.
    \item Infine, si esegue il \textbf{matching} vero e proprio sui grafi rimanenti, usando un algoritmo di subgraph matching (ad es.\ VF2, RI-DS) per verificare se la query è effettivamente un sottografo del grafo target.
\end{enumerate}

\section*{Riferimenti}
I riferimenti per questo capitolo sono:
\begin{itemize}
    \item Articolo originale dell'algoritmo Vento-Foggia\cite{Cordella1999VF}
    \item Articolo originale dell'algoritmo VF2\cite{Cordella2004VF2}
    \item Articolo dell'algoritmo RI e RI-DS \cite{Bonnici2013RI}
\end{itemize}

